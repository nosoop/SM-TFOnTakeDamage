#if defined __autogenerated_methodmap_{{classname}}_included
	#endinput
#endif

#define __autogenerated_methodmap_{{classname}}_included

/**
 * {{classname}} instance members.  These can be used to dynamically update the offsets if
 * necessary, such as through gameconf.
 */
{{#decl_variables}}
any {{var}} = {{assign}};
{{/decl_variables}}

{{#array_type_defs}}
#if !defined __autogenerated_methodmap_array_{{type}}{{count}}_included
#define __autogenerated_methodmap_array_{{type}}{{count}}_included
/**
 * Methodmap that implements a wrapper around a {{type}}[{{count}}] array to expose get / set
 * functions.
 */
methodmap {{name}} {
	property Address Address {
		public get() {
			return view_as<Address>(this);
		}
	}
	public void Get({{type}} value[{{count}}]) {
		for (int i; i < {{count}}; i++) {
			value[i] = view_as<{{type}}>(LoadFromAddress(this.Address + view_as<Address>({{stride}} * i), {{size}}));
		}
	}
	public void Set(const {{type}} value[{{count}}]) {
		for (int i; i < {{count}}; i++) {
			StoreToAddress(this.Address + view_as<Address>({{stride}} * i), view_as<any>(value[i]), {{size}});
		}
	}
	public {{type}} GetIndex(int index) {
		if (index < 0 || index >= {{count}}) {
			ThrowError("Index %d is out of bounds (limit {{count}})", index);
		}
		return view_as<{{type}}>(LoadFromAddress(this.Address + view_as<Address>({{stride}} * index), {{size}}));
	}
	public void SetIndex(int index, {{type}} value) {
		if (index < 0 || index >= {{count}}) {
			ThrowError("Index %d is out of bounds (limit {{count}})", index);
		}
		StoreToAddress(this.Address + view_as<Address>({{stride}} * index), view_as<any>(value), {{size}});
	}
}
#endif
{{/array_type_defs}}

/**
 * This is an autogenerated methodmap to access the properties of an in-memory
 * {{classname}} instance.
 */
methodmap {{classname}}{{#inherits}} < {{inherits}}{{/inherits}} {
	/**
	 * Returns the address casted to a {{classname}} methodmap instance.
	 */
	public static {{classname}} FromAddress(Address pInstance) {
		return view_as<{{classname}}>(pInstance);
	}
	
	/**
	 * Developers may want to implement their own methods on this methodmap; they can be
	 * automatically included here.
	 */
	#tryinclude "classmethods/{{classname}}.sp"
	
	property Address Address {
		public get() {
			return view_as<Address>(this);
		}
	}
{{#properties}}
	
	property {{type}} {{name}} {
		public get() {
{{^inline}}
			return view_as<{{type}}>(LoadFromAddress(this.Address + view_as<Address>({{offset}}), {{size}}));
{{/inline}}
{{#inline}}
			return view_as<{{type}}>(this.Address + view_as<Address>({{offset}}));
{{/inline}}
		}{{#writable}}{{^inline}}
		public set({{type}} value) {
			StoreToAddress(this.Address + view_as<Address>({{offset}}), view_as<any>(value), {{size}});
		}{{/inline}}{{/writable}}
	}
{{/properties}}
{{#size}}
	
	public static int GetClassSize() {
		return {{size}};
	}
{{/size}}
}
